<!DOCTYPE html>
<html lang="" xml:lang="">
<head>

  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <title>Chapter 9 파라미터 추정 방법 및 세팅 | PIPET / Q-fitter Pharmacometrics Course: Basic 1 모델 구축의 기초</title>
  <meta name="description" content="이 교재는 약동-약력학 모델링을 위해 가장 널리 사용하는 NONMEM 소프트웨어를 활용하기 위에 알아야 하는 기본개념들과 그 사용법을 소개하기 위하여 만들어졌다." />
  <meta name="generator" content="bookdown 0.18 and GitBook 2.6.7" />

  <meta property="og:title" content="Chapter 9 파라미터 추정 방법 및 세팅 | PIPET / Q-fitter Pharmacometrics Course: Basic 1 모델 구축의 기초" />
  <meta property="og:type" content="book" />
  <meta property="og:url" content="https://pipetcpt.github.io/book-basic-1" />
  <meta property="og:image" content="https://pipetcpt.github.io/book-basic-1images/cover.jpg" />
  <meta property="og:description" content="이 교재는 약동-약력학 모델링을 위해 가장 널리 사용하는 NONMEM 소프트웨어를 활용하기 위에 알아야 하는 기본개념들과 그 사용법을 소개하기 위하여 만들어졌다." />
  <meta name="github-repo" content="pipetcpt/book-basic-1" />

  <meta name="twitter:card" content="summary" />
  <meta name="twitter:title" content="Chapter 9 파라미터 추정 방법 및 세팅 | PIPET / Q-fitter Pharmacometrics Course: Basic 1 모델 구축의 기초" />
  
  <meta name="twitter:description" content="이 교재는 약동-약력학 모델링을 위해 가장 널리 사용하는 NONMEM 소프트웨어를 활용하기 위에 알아야 하는 기본개념들과 그 사용법을 소개하기 위하여 만들어졌다." />
  <meta name="twitter:image" content="https://pipetcpt.github.io/book-basic-1images/cover.jpg" />

<meta name="author" content="임동석, 이소진, 배수현, 전상일, 홍태곤, 한승훈, 김정렬" />


<meta name="date" content="2020-04-28" />

  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black" />
  
  
<link rel="prev" href="초기추정값.html"/>
<link rel="next" href="nonmem-실행결과-해석-및-xpose4-사용법.html"/>
<script src="libs/header-attrs/header-attrs.js"></script>
<script src="libs/jquery/jquery.min.js"></script>
<link href="libs/gitbook/css/style.css" rel="stylesheet" />
<link href="libs/gitbook/css/plugin-table.css" rel="stylesheet" />
<link href="libs/gitbook/css/plugin-bookdown.css" rel="stylesheet" />
<link href="libs/gitbook/css/plugin-highlight.css" rel="stylesheet" />
<link href="libs/gitbook/css/plugin-search.css" rel="stylesheet" />
<link href="libs/gitbook/css/plugin-fontsettings.css" rel="stylesheet" />
<link href="libs/gitbook/css/plugin-clipboard.css" rel="stylesheet" />












<link rel="stylesheet" href="css\style.css" type="text/css" />
</head>

<body>



  <div class="book without-animation with-summary font-size-2 font-family-1" data-basepath=".">

    <div class="book-summary">
      <nav role="navigation">

<ul class="summary">
<li><a href="./">Basic 1 모델 구축의 기초</a></li>

<li class="divider"></li>
<li class="chapter" data-level="" data-path="index.html"><a href="index.html"><i class="fa fa-check"></i>서문</a></li>
<li class="chapter" data-level="1" data-path="계량약리학과-관련-개념들.html"><a href="계량약리학과-관련-개념들.html"><i class="fa fa-check"></i><b>1</b> 계량약리학과 관련 개념들</a>
<ul>
<li class="chapter" data-level="1.1" data-path="계량약리학과-관련-개념들.html"><a href="계량약리학과-관련-개념들.html#소개"><i class="fa fa-check"></i><b>1.1</b> 소개</a></li>
<li class="chapter" data-level="1.2" data-path="계량약리학과-관련-개념들.html"><a href="계량약리학과-관련-개념들.html#혼합효과-모델링-mixed-effects-modeling"><i class="fa fa-check"></i><b>1.2</b> 혼합효과 모델링 Mixed-effects modeling</a>
<ul>
<li class="chapter" data-level="1.2.1" data-path="계량약리학과-관련-개념들.html"><a href="계량약리학과-관련-개념들.html#집단의-데이터를-처리하는-세가지-방법"><i class="fa fa-check"></i><b>1.2.1</b> 집단의 데이터를 처리하는 세가지 방법</a></li>
<li class="chapter" data-level="1.2.2" data-path="계량약리학과-관련-개념들.html"><a href="계량약리학과-관련-개념들.html#혼합효과-모델링의-개념"><i class="fa fa-check"></i><b>1.2.2</b> 혼합효과 모델링의 개념</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="2" data-path="nonmem-데이터셋.html"><a href="nonmem-데이터셋.html"><i class="fa fa-check"></i><b>2</b> NONMEM 데이터셋</a>
<ul>
<li class="chapter" data-level="2.1" data-path="nonmem-데이터셋.html"><a href="nonmem-데이터셋.html#필수-제어구문-작성-방법"><i class="fa fa-check"></i><b>2.1</b> 필수 제어구문 작성 방법</a>
<ul>
<li class="chapter" data-level="2.1.1" data-path="nonmem-데이터셋.html"><a href="nonmem-데이터셋.html#prob-레코드-작성"><i class="fa fa-check"></i><b>2.1.1</b> $PROB 레코드 작성</a></li>
<li class="chapter" data-level="2.1.2" data-path="nonmem-데이터셋.html"><a href="nonmem-데이터셋.html#data-레코드-작성"><i class="fa fa-check"></i><b>2.1.2</b> $DATA 레코드 작성</a></li>
<li class="chapter" data-level="2.1.3" data-path="nonmem-데이터셋.html"><a href="nonmem-데이터셋.html#input-레코드-작성"><i class="fa fa-check"></i><b>2.1.3</b> $INPUT 레코드 작성</a></li>
</ul></li>
<li class="chapter" data-level="2.2" data-path="nonmem-데이터셋.html"><a href="nonmem-데이터셋.html#predpp에-쓰는-데이터셋"><i class="fa fa-check"></i><b>2.2</b> PREDPP에 쓰는 데이터셋</a></li>
<li class="chapter" data-level="2.3" data-path="nonmem-데이터셋.html"><a href="nonmem-데이터셋.html#데이터셋-소개"><i class="fa fa-check"></i><b>2.3</b> 데이터셋 소개</a></li>
<li class="chapter" data-level="2.4" data-path="nonmem-데이터셋.html"><a href="nonmem-데이터셋.html#데이터셋-배열"><i class="fa fa-check"></i><b>2.4</b> 데이터셋 배열</a></li>
<li class="chapter" data-level="2.5" data-path="nonmem-데이터셋.html"><a href="nonmem-데이터셋.html#지정된-데이터-아이템-레이블-reserved-labels"><i class="fa fa-check"></i><b>2.5</b> 지정된 데이터 아이템 레이블 Reserved Labels</a>
<ul>
<li class="chapter" data-level="2.5.1" data-path="nonmem-데이터셋.html"><a href="nonmem-데이터셋.html#id"><i class="fa fa-check"></i><b>2.5.1</b> ID</a></li>
<li class="chapter" data-level="2.5.2" data-path="nonmem-데이터셋.html"><a href="nonmem-데이터셋.html#dv"><i class="fa fa-check"></i><b>2.5.2</b> DV</a></li>
<li class="chapter" data-level="2.5.3" data-path="nonmem-데이터셋.html"><a href="nonmem-데이터셋.html#mdv"><i class="fa fa-check"></i><b>2.5.3</b> MDV</a></li>
<li class="chapter" data-level="2.5.4" data-path="nonmem-데이터셋.html"><a href="nonmem-데이터셋.html#evid"><i class="fa fa-check"></i><b>2.5.4</b> EVID</a></li>
<li class="chapter" data-level="2.5.5" data-path="nonmem-데이터셋.html"><a href="nonmem-데이터셋.html#time"><i class="fa fa-check"></i><b>2.5.5</b> TIME</a></li>
<li class="chapter" data-level="2.5.6" data-path="nonmem-데이터셋.html"><a href="nonmem-데이터셋.html#amt"><i class="fa fa-check"></i><b>2.5.6</b> AMT</a></li>
<li class="chapter" data-level="2.5.7" data-path="nonmem-데이터셋.html"><a href="nonmem-데이터셋.html#rate"><i class="fa fa-check"></i><b>2.5.7</b> RATE</a></li>
<li class="chapter" data-level="2.5.8" data-path="nonmem-데이터셋.html"><a href="nonmem-데이터셋.html#addl-ii"><i class="fa fa-check"></i><b>2.5.8</b> ADDL &amp; II</a></li>
<li class="chapter" data-level="2.5.9" data-path="nonmem-데이터셋.html"><a href="nonmem-데이터셋.html#ss"><i class="fa fa-check"></i><b>2.5.9</b> SS</a></li>
<li class="chapter" data-level="2.5.10" data-path="nonmem-데이터셋.html"><a href="nonmem-데이터셋.html#cmt"><i class="fa fa-check"></i><b>2.5.10</b> CMT</a></li>
<li class="chapter" data-level="2.5.11" data-path="nonmem-데이터셋.html"><a href="nonmem-데이터셋.html#covariates"><i class="fa fa-check"></i><b>2.5.11</b> Covariates</a></li>
</ul></li>
<li class="chapter" data-level="2.6" data-path="nonmem-데이터셋.html"><a href="nonmem-데이터셋.html#참고문헌"><i class="fa fa-check"></i><b>2.6</b> 참고문헌</a></li>
</ul></li>
<li class="chapter" data-level="3" data-path="nonmem-모델-종류-별-제어구문-소개.html"><a href="nonmem-모델-종류-별-제어구문-소개.html"><i class="fa fa-check"></i><b>3</b> NONMEM 모델 종류 별 제어구문 소개</a>
<ul>
<li class="chapter" data-level="3.1" data-path="nonmem-모델-종류-별-제어구문-소개.html"><a href="nonmem-모델-종류-별-제어구문-소개.html#소개-1"><i class="fa fa-check"></i><b>3.1</b> 소개</a></li>
<li class="chapter" data-level="3.2" data-path="nonmem-모델-종류-별-제어구문-소개.html"><a href="nonmem-모델-종류-별-제어구문-소개.html#제어구문의-구성"><i class="fa fa-check"></i><b>3.2</b> 제어구문의 구성</a></li>
<li class="chapter" data-level="3.3" data-path="nonmem-모델-종류-별-제어구문-소개.html"><a href="nonmem-모델-종류-별-제어구문-소개.html#predpp와-pred"><i class="fa fa-check"></i><b>3.3</b> PREDPP와 PRED</a></li>
<li class="chapter" data-level="3.4" data-path="nonmem-모델-종류-별-제어구문-소개.html"><a href="nonmem-모델-종류-별-제어구문-소개.html#제어구문에-쓰이는-레코드"><i class="fa fa-check"></i><b>3.4</b> 제어구문에 쓰이는 레코드</a>
<ul>
<li class="chapter" data-level="3.4.1" data-path="nonmem-모델-종류-별-제어구문-소개.html"><a href="nonmem-모델-종류-별-제어구문-소개.html#subroutine-model-pk-des"><i class="fa fa-check"></i><b>3.4.1</b> $SUBROUTINE, $MODEL, $PK, $DES</a></li>
<li class="chapter" data-level="3.4.2" data-path="nonmem-모델-종류-별-제어구문-소개.html"><a href="nonmem-모델-종류-별-제어구문-소개.html#theta-omega-sigma"><i class="fa fa-check"></i><b>3.4.2</b> $THETA, $OMEGA, $SIGMA</a></li>
<li class="chapter" data-level="3.4.3" data-path="nonmem-모델-종류-별-제어구문-소개.html"><a href="nonmem-모델-종류-별-제어구문-소개.html#estimation-simulation"><i class="fa fa-check"></i><b>3.4.3</b> $ESTIMATION, $SIMULATION</a></li>
<li class="chapter" data-level="3.4.4" data-path="nonmem-모델-종류-별-제어구문-소개.html"><a href="nonmem-모델-종류-별-제어구문-소개.html#covariance-table"><i class="fa fa-check"></i><b>3.4.4</b> $COVARIANCE, $TABLE</a></li>
</ul></li>
<li class="chapter" data-level="3.5" data-path="nonmem-모델-종류-별-제어구문-소개.html"><a href="nonmem-모델-종류-별-제어구문-소개.html#모델-종류별-제어구문"><i class="fa fa-check"></i><b>3.5</b> 모델 종류별 제어구문</a>
<ul>
<li class="chapter" data-level="3.5.1" data-path="nonmem-모델-종류-별-제어구문-소개.html"><a href="nonmem-모델-종류-별-제어구문-소개.html#특수-advan과-일반-advan"><i class="fa fa-check"></i><b>3.5.1</b> 특수 ADVAN과 일반 ADVAN</a></li>
<li class="chapter" data-level="3.5.2" data-path="nonmem-모델-종류-별-제어구문-소개.html"><a href="nonmem-모델-종류-별-제어구문-소개.html#일반-비선형-모델"><i class="fa fa-check"></i><b>3.5.2</b> 일반 비선형 모델</a></li>
<li class="chapter" data-level="3.5.3" data-path="nonmem-모델-종류-별-제어구문-소개.html"><a href="nonmem-모델-종류-별-제어구문-소개.html#pred-모델"><i class="fa fa-check"></i><b>3.5.3</b> PRED 모델</a></li>
</ul></li>
<li class="chapter" data-level="3.6" data-path="nonmem-모델-종류-별-제어구문-소개.html"><a href="nonmem-모델-종류-별-제어구문-소개.html#참고문헌-1"><i class="fa fa-check"></i><b>3.6</b> 참고문헌</a></li>
</ul></li>
<li class="chapter" data-level="4" data-path="특수-advan을-이용한-control-stream의-코딩.html"><a href="특수-advan을-이용한-control-stream의-코딩.html"><i class="fa fa-check"></i><b>4</b> 특수 ADVAN을 이용한 control stream의 코딩</a></li>
<li class="chapter" data-level="5" data-path="일반-advan을-이용한-control-stream의-코딩.html"><a href="일반-advan을-이용한-control-stream의-코딩.html"><i class="fa fa-check"></i><b>5</b> 일반 ADVAN을 이용한 control stream의 코딩</a></li>
<li class="chapter" data-level="6" data-path="기타-advan.html"><a href="기타-advan.html"><i class="fa fa-check"></i><b>6</b> 기타 ADVAN</a>
<ul>
<li class="chapter" data-level="6.1" data-path="기타-advan.html"><a href="기타-advan.html#advan9---general-nonlinear-model-with-equilibrium-compartments"><i class="fa fa-check"></i><b>6.1</b> ADVAN9 - General Nonlinear Model with Equilibrium Compartments</a></li>
<li class="chapter" data-level="6.2" data-path="기타-advan.html"><a href="기타-advan.html#advan10---one-compartment-model-with-michaelis-menten-elimination"><i class="fa fa-check"></i><b>6.2</b> ADVAN10 - One Compartment Model with Michaelis-Menten Elimination</a></li>
<li class="chapter" data-level="6.3" data-path="기타-advan.html"><a href="기타-advan.html#advan11과-12---three-compartment-linear-model-iv-and-first-order-absorption"><i class="fa fa-check"></i><b>6.3</b> ADVAN11과 12 - Three Compartment Linear Model (IV and First Order Absorption)</a></li>
<li class="chapter" data-level="6.4" data-path="기타-advan.html"><a href="기타-advan.html#advan13---general-nonlinear-model-using-lsoda"><i class="fa fa-check"></i><b>6.4</b> ADVAN13 - General Nonlinear Model using LSODA</a></li>
</ul></li>
<li class="chapter" data-level="7" data-path="pred-advan을-쓰지-않는-코딩.html"><a href="pred-advan을-쓰지-않는-코딩.html"><i class="fa fa-check"></i><b>7</b> $PRED: ADVAN을 쓰지 않는 코딩</a></li>
<li class="chapter" data-level="8" data-path="초기추정값.html"><a href="초기추정값.html"><i class="fa fa-check"></i><b>8</b> 초기추정값</a>
<ul>
<li class="chapter" data-level="8.1" data-path="초기추정값.html"><a href="초기추정값.html#서론"><i class="fa fa-check"></i><b>8.1</b> 서론</a></li>
<li class="chapter" data-level="8.2" data-path="초기추정값.html"><a href="초기추정값.html#초기-추정값의-의미와-역할"><i class="fa fa-check"></i><b>8.2</b> 초기 추정값의 의미와 역할</a></li>
<li class="chapter" data-level="8.3" data-path="초기추정값.html"><a href="초기추정값.html#왜-좋은-초기추정값을-선택해야-하는가"><i class="fa fa-check"></i><b>8.3</b> 왜 좋은 초기추정값을 선택해야 하는가?</a></li>
<li class="chapter" data-level="8.4" data-path="초기추정값.html"><a href="초기추정값.html#고정효과-임의효과-파라미터의-의미와-초기추정값의-지정"><i class="fa fa-check"></i><b>8.4</b> 고정효과, 임의효과 파라미터의 의미와 초기추정값의 지정</a></li>
<li class="chapter" data-level="8.5" data-path="초기추정값.html"><a href="초기추정값.html#theta의-초기추정값-지정"><i class="fa fa-check"></i><b>8.5</b> THETA의 초기추정값 지정</a></li>
<li class="chapter" data-level="8.6" data-path="초기추정값.html"><a href="초기추정값.html#omega의-초기추정값-지정"><i class="fa fa-check"></i><b>8.6</b> OMEGA의 초기추정값 지정</a></li>
<li class="chapter" data-level="8.7" data-path="초기추정값.html"><a href="초기추정값.html#sigma의-초기추정값-지정"><i class="fa fa-check"></i><b>8.7</b> SIGMA의 초기추정값 지정</a></li>
</ul></li>
<li class="chapter" data-level="9" data-path="파라미터-추정-방법-및-세팅.html"><a href="파라미터-추정-방법-및-세팅.html"><i class="fa fa-check"></i><b>9</b> 파라미터 추정 방법 및 세팅</a>
<ul>
<li class="chapter" data-level="9.1" data-path="파라미터-추정-방법-및-세팅.html"><a href="파라미터-추정-방법-및-세팅.html#추정-방법-및-관련-옵션"><i class="fa fa-check"></i><b>9.1</b> 추정 방법 및 관련 옵션</a>
<ul>
<li class="chapter" data-level="9.1.1" data-path="파라미터-추정-방법-및-세팅.html"><a href="파라미터-추정-방법-및-세팅.html#noabort"><i class="fa fa-check"></i><b>9.1.1</b> NOABORT</a></li>
<li class="chapter" data-level="9.1.2" data-path="파라미터-추정-방법-및-세팅.html"><a href="파라미터-추정-방법-및-세팅.html#maxeval"><i class="fa fa-check"></i><b>9.1.2</b> MAXEVAL</a></li>
<li class="chapter" data-level="9.1.3" data-path="파라미터-추정-방법-및-세팅.html"><a href="파라미터-추정-방법-및-세팅.html#method"><i class="fa fa-check"></i><b>9.1.3</b> METHOD</a></li>
<li class="chapter" data-level="9.1.4" data-path="파라미터-추정-방법-및-세팅.html"><a href="파라미터-추정-방법-및-세팅.html#interaction"><i class="fa fa-check"></i><b>9.1.4</b> INTERACTION</a></li>
<li class="chapter" data-level="9.1.5" data-path="파라미터-추정-방법-및-세팅.html"><a href="파라미터-추정-방법-및-세팅.html#print"><i class="fa fa-check"></i><b>9.1.5</b> PRINT</a></li>
</ul></li>
<li class="chapter" data-level="9.2" data-path="파라미터-추정-방법-및-세팅.html"><a href="파라미터-추정-방법-및-세팅.html#nonmem-추정"><i class="fa fa-check"></i><b>9.2</b> NONMEM 추정</a>
<ul>
<li class="chapter" data-level="9.2.1" data-path="파라미터-추정-방법-및-세팅.html"><a href="파라미터-추정-방법-및-세팅.html#ols-방식"><i class="fa fa-check"></i><b>9.2.1</b> OLS 방식</a></li>
<li class="chapter" data-level="9.2.2" data-path="파라미터-추정-방법-및-세팅.html"><a href="파라미터-추정-방법-및-세팅.html#wls-방식"><i class="fa fa-check"></i><b>9.2.2</b> WLS 방식</a></li>
<li class="chapter" data-level="9.2.3" data-path="파라미터-추정-방법-및-세팅.html"><a href="파라미터-추정-방법-및-세팅.html#els-방식"><i class="fa fa-check"></i><b>9.2.3</b> ELS 방식</a></li>
</ul></li>
<li class="chapter" data-level="9.3" data-path="파라미터-추정-방법-및-세팅.html"><a href="파라미터-추정-방법-및-세팅.html#likelihood"><i class="fa fa-check"></i><b>9.3</b> Likelihood</a></li>
<li class="chapter" data-level="9.4" data-path="파라미터-추정-방법-및-세팅.html"><a href="파라미터-추정-방법-및-세팅.html#taylor-전개식"><i class="fa fa-check"></i><b>9.4</b> Taylor 전개식</a></li>
<li class="chapter" data-level="9.5" data-path="파라미터-추정-방법-및-세팅.html"><a href="파라미터-추정-방법-및-세팅.html#likelihood-ratio-test"><i class="fa fa-check"></i><b>9.5</b> Likelihood Ratio Test</a></li>
</ul></li>
<li class="chapter" data-level="10" data-path="nonmem-실행결과-해석-및-xpose4-사용법.html"><a href="nonmem-실행결과-해석-및-xpose4-사용법.html"><i class="fa fa-check"></i><b>10</b> NONMEM 실행결과 해석 및 Xpose4 사용법</a></li>
<li class="chapter" data-level="11" data-path="공변량-분석.html"><a href="공변량-분석.html"><i class="fa fa-check"></i><b>11</b> 공변량 분석</a>
<ul>
<li class="chapter" data-level="11.1" data-path="공변량-분석.html"><a href="공변량-분석.html#서론-1"><i class="fa fa-check"></i><b>11.1</b> 서론</a></li>
<li class="chapter" data-level="11.2" data-path="공변량-분석.html"><a href="공변량-분석.html#공변량-분석의-일반적-절차"><i class="fa fa-check"></i><b>11.2</b> 공변량 분석의 일반적 절차</a>
<ul>
<li class="chapter" data-level="11.2.1" data-path="공변량-분석.html"><a href="공변량-분석.html#항목-평가-variable-evaluation"><i class="fa fa-check"></i><b>11.2.1</b> 항목 평가 (variable evaluation)</a></li>
<li class="chapter" data-level="11.2.2" data-path="공변량-분석.html"><a href="공변량-분석.html#공변량-스크리닝-covariate-screening"><i class="fa fa-check"></i><b>11.2.2</b> 공변량 스크리닝 (covariate screening)</a></li>
<li class="chapter" data-level="11.2.3" data-path="공변량-분석.html"><a href="공변량-분석.html#공선성co-linearity에-대한-고려"><i class="fa fa-check"></i><b>11.2.3</b> 공선성(co-linearity)에 대한 고려</a></li>
<li class="chapter" data-level="11.2.4" data-path="공변량-분석.html"><a href="공변량-분석.html#공변량-평가-전진선택forward-selection"><i class="fa fa-check"></i><b>11.2.4</b> 공변량 평가: 전진선택(forward-selection)</a></li>
<li class="chapter" data-level="11.2.5" data-path="공변량-분석.html"><a href="공변량-분석.html#공변량-평가-후진제거backward-elimination"><i class="fa fa-check"></i><b>11.2.5</b> 공변량 평가: 후진제거(backward-elimination)</a></li>
</ul></li>
<li class="chapter" data-level="11.3" data-path="공변량-분석.html"><a href="공변량-분석.html#공변량-분석-관련-추가-고려-사항"><i class="fa fa-check"></i><b>11.3</b> 공변량 분석 관련 추가 고려 사항</a></li>
</ul></li>
<li class="chapter" data-level="12" data-path="참고문헌-2.html"><a href="참고문헌-2.html"><i class="fa fa-check"></i><b>12</b> 참고문헌</a></li>
<li class="divider"></li>
<li><a href="https://github.com/pipetcpt" target="_blank">Published by PIPET</a></li>

</ul>

      </nav>
    </div>

    <div class="book-body">
      <div class="body-inner">
        <div class="book-header" role="navigation">
          <h1>
            <i class="fa fa-circle-o-notch fa-spin"></i><a href="./">PIPET / Q-fitter Pharmacometrics Course: Basic 1 모델 구축의 기초</a>
          </h1>
        </div>

        <div class="page-wrapper" tabindex="-1" role="main">
          <div class="page-inner">

            <section class="normal" id="section-">
<div id="파라미터-추정-방법-및-세팅" class="section level1" number="9">
<h1><span class="header-section-number">Chapter 9</span> 파라미터 추정 방법 및 세팅</h1>
<p><strong>Estimation Methods &amp; Settings</strong></p>
<p><em>김정렬</em></p>
<div id="추정-방법-및-관련-옵션" class="section level2" number="9.1">
<h2><span class="header-section-number">9.1</span> 추정 방법 및 관련 옵션</h2>
<pre><code>$ESTIMATION NOABORT MAXEVAL=9999 METHOD=1 INTER PRINT=10 SIGDIGITS=3</code></pre>
<p>$ESTIMATION 레코드에는 종종 위와 유사한 구문을 쓰게 되고, 이는 NONMEM으로 하여금 어떤 방식으로 파라미터를
추정하고 그 결과를 출력할 것인지에 대한 옵션을 제시하는 것이다. 이중에는 NONMEM이 실행되기 위해 반드시
정의되어야 하는 옵션이 있는 반면, 일부는 생략하더라도 사전에 정해진 값이 적용되어 아무런 문제없이 NONMEM을
실행할 수 있다.</p>
<div id="noabort" class="section level3" number="9.1.1">
<h3><span class="header-section-number">9.1.1</span> NOABORT</h3>
<p>NONMEM이 파라미터를 추정하는 동안 함수 계산을 하다 보면 계산이 불가능한 상황이 발생하기도 하며 이 경우 NONMEM은 더
이상 추정 과정을 실행하지 않고 그 상태로 중단된다. 지나치게 크거나 작은 값과 같이 적절하지 않은 초기 추정값이 지정되었거나
주어진 정보의 양에 비해 추정하고자 하는 파라미터가 지나치게 많을 때 종종 발생한다. 이때 NOABORT 옵션을 주면 NONMEM
자체의 기능을 통해 적절하게 값을 복구(recovery)함으로써 추정 과정을 계속하게 됨으로써 이런 상황을 일부 회피할 수 있다.
그러나 이 옵션만으로 모든 문제를 완벽하게 해결할 수 있는 것은 아니며, 개발한 모델 구조가 자료를 제대로 설명하지 못한다면 이
옵션을 사용했음에도 중단되는 경우가 많다.</p>
</div>
<div id="maxeval" class="section level3" number="9.1.2">
<h3><span class="header-section-number">9.1.2</span> MAXEVAL</h3>
<p>NONMEM이 목적함수 값(objective function value)을 계산하기 위해 지나치게 많은 추정을 반복하다 보면,
실행 속도가 느려질 뿐만 아니라 추정된 최종 파라미터가 지나치게 크거나 작은 값으로 나오는 등 부적절한 경우가 있다. 이때
목적함수 계산이 적절한 수준에 이르면 그만해도 좋다는 옵션을 MAXEVAL 값으로 줄 수 있다. 예를 들어
MAXEVAL=10000으로 정의하면, 10,000번 까지만 계산하고 더 이상 진행하지 않고 마지막 계산된 파라미터를 최종 값으로
확정하라는 의미이다. 통상의 NONMEM 결과에서 MAXEVAL 값은 자료량이 충분해 파라미터가 잘 추정되면 10번 이내인 경우도
있고, 추정 파라미터가 많고 모델이 복잡한 경우라도 100을 넘지 않기 경우가 많다. 따라서 10,000번 이상 계산해야 한다는
것은 부적절할 수 있으니 불필요한 계산을 지속하지 않도록 하는 것이다. 물론 자료가 매우 많고 파라미터 추정이 쉽지 않은
복잡한 모델이라면 계산을 지속할 수 있으니 지나치게 낮은 값으로 설정할 필요는 없다. 컴퓨터 성능이 떨어져 NONMEM
실행에 오랜 시간이 걸리던 과거에는 프로그램 실행 시간을 줄이고 효율적인 작업을 위해 해당 옵션이 필요했을 것으로 생각되지만,
현재 컴퓨터 성능이라면 시간이 오래 걸리지 않기 때문에 해당 옵션은 설정하지 않아도 될 것이다.</p>
</div>
<div id="method" class="section level3" number="9.1.3">
<h3><span class="header-section-number">9.1.3</span> METHOD</h3>
<p>NONMEM이 파라미터를 추정하는 방법은 METHOD 옵션으로 설정한다. 이중 First Order (FO) 방식은 ‘method
= FO’ 또는 ‘method = 0’ 같이 설정하며, 이 값이 기본(default) 설정이므로 FO 방식을 적용하고자 한다면
생략해도 무방하다. 이 방식은 NONMEM이 파라미터를 추정할 때 근사하는 Taylor series 식에 이용되는 개별 η
값의 합을 0으로 가정하여 계산하는 방식을 말하며, 복잡한 계산식이 단순하게 되어 파라미터 추정을 빠르게 할 수 있는 장점이
있다. 그런데 계산이 빨라지는 대신 추정 파라미터에 비뚤림(bias)이 발생하게 되므로, 각 파라미터의 대략의 값을
추정하고자 한다면 FO 방식을 이용할 수 있다.</p>
<p>FOCE 방식은 단순 FO가 아닌 Conditional Estimation을 의미하며, 개별 η 값의 합을 0으로 가정하는 FO
방식과 달리 실제 추정한 η 값의 합을 이용하므로 계산식이 복잡해 실행 시간이 오래 걸리는 반면 보다 정확한 값을 얻을 수
있는 것으로 알려져 있다. 이 방식은 ‘method = cond’ 또는 ‘method = 1’로 표현할 수 있다. FO
방식에 비해 비뚤림이 적게 발생하기 때문에 개별 값을 좀더 정확하게 추정하기 위해서는 FOCE 방식을 쓴다.(표 1)</p>
<p><img src="assets/media-09/image2.png" /></p>
<table>
<thead>
<tr class="header">
<th align="left">Comparison</th>
<th align="left">FO</th>
<th align="left">FOCE</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">연산속도</td>
<td align="left">빠르다</td>
<td align="left">느리다</td>
</tr>
<tr class="even">
<td align="left">자료의 양</td>
<td align="left">Sparse</td>
<td align="left">Dense</td>
</tr>
<tr class="odd">
<td align="left">Ω의 크기 작</td>
<td align="left">을 때 클</td>
<td align="left">때</td>
</tr>
<tr class="even">
<td align="left">비선형 정도</td>
<td align="left">작다</td>
<td align="left">크다</td>
</tr>
<tr class="odd">
<td align="left">실례</td>
<td align="left">새로운 자료를 분석, 최신 모형을 적용</td>
<td align="left">집단약력학 모형, 범주형 또는 이산형 자료</td>
</tr>
</tbody>
</table>
</div>
<div id="interaction" class="section level3" number="9.1.4">
<h3><span class="header-section-number">9.1.4</span> INTERACTION</h3>
<p>파라미터 추정 시 η와 ε 사이의 상호작용을 가정할 때 해당 옵션을 설정한다. 개체간 차이를 의미하는 η와 잔차인 ε 사이의
예상되는 상호작용을 무시하면 파라미터 추정 시 비뚤림이 발생하게 된다. 특히 Y = F * (1 + ε) 또는 Y =
F * (1 + ε<sub>1</sub>) + ε<sub>2</sub> 같은 잔차 모델을 사용하는 경우 상호작용을 고려하는 것이
통계학적으로 적절하며, Y = F + ε와 같이 표현되는 잔차 모델에서는 이런 상호작용 설정이 파라미터 추정 결과와 무관한 것으로
알려져 있다.</p>
</div>
<div id="print" class="section level3" number="9.1.5">
<h3><span class="header-section-number">9.1.5</span> PRINT</h3>
<p>NONMEM이 실행되면 파라미터를 추정하기 위해 되풀이(iteration)를 반복하게 되는데 그 중간 과정을 보여달라는 옵션이다.
이 옵션을 설정하지 않으면 처음에 시작한다는 문구가 뜬 후 바로 이어 최종 결과가 제시된다. 즉 중간에 어떤 과정으로 진행되었는지
알 수 없으며, 추정하는데 시간이 오래 걸리는 경우 제대로 실행되고 있는지 확인하기 어렵다. 그래서 중간중간 진행 과정을 확인하기
위해 해당 옵션을 이용할 수 있다. 예를 들어 10으로 설정하면 되풀이를 10번 할 때마다 중간 과정을 보여주기 때문에 이를 통해
각 파라미터가 어떤 값으로 수렴하는지 확인할 수 있다. 그런데 최근 컴퓨터는 계산을 빠르게 처리하기 때문에 중간 과정이 순식간에
지나가 실제 값을 확인하기 어려워 설정하는 의미가 없는 경우도 있다.</p>
</div>
</div>
<div id="nonmem-추정" class="section level2" number="9.2">
<h2><span class="header-section-number">9.2</span> NONMEM 추정</h2>
<p>NONMEM은 목적함수(objective function)를 최적화하는 방식으로 파라미터를 추정하게 되고, 이때 최적화된 목적함수
값(Objective Function Value, OFV)이 산출된다. 개발한 모델로부터 산출된 OFV는 가능도비
검정(Likelihood Ratio Test, LRT) 방법을 이용함으로써 보다 적절한 모델을 선정할 수도 있다. 여기
제시된 내용은 수학자가 아닌 이상 정확하게 이해하기는 쉽지 않지만, 개념적으로 간단히 도식화하면 그림 1과 같다.</p>
<p><img src="assets/media-09/image3.png" /></p>
<p>그림 1</p>
<p>일반적으로 우리는 주어진 자료를 설명하기 위해 다양한 파라미터가 포함된 모델을 개발하게 되고 이를 NONMEM으로 실행하게 될
것이다. 이때 NONMEM은 목적함수를 계산하게 되고 이 값이 최소화되는 파라미터 조합을 output 파일을 통해
제시한다. 어떤 형태로 목적함수를 설정하느냐에 따라 OLS, WLS, ELS 방법 여러 가지 방식들이 이용된다.</p>
<div id="ols-방식" class="section level3" number="9.2.1">
<h3><span class="header-section-number">9.2.1</span> OLS 방식</h3>
<p>OLS (ordinary least square) 방식은 단순 선형회귀(linear regression)를 하는 걸 말하며,
흔하게 사용된다. 이는 SAS, SPSS 등 통계 프로그램에서 사용하는 선형회귀 방식과 동일하다. 예를 들어 용량에
따른 약동학 파라미터 AUC의 상관관계를 파악하기 위해 그래프를 그리고 가상의 선을 설정하여 ‘용량에 따라 AUC는
증가한다’는 결론을 내리는 것이 전형적인 OLS 방식이다.(그림 2)</p>
<p><img src="assets/media-09/image4.png" /></p>
<p>그림 2</p>
<p>회귀를 통해 자료를 설명할 때 관찰값과 예측값 간의 차이를 잔차(residual) 또는 오차(error)라고 표현하는데, OLS
방식에서는 아래 수식과 같이 이 잔차를 제곱해서 나온 값의 합, 즉 잔차제곱합을 최소화하는 파라미터 조합을 찾게 된다.</p>
<p><span class="math display">\[\text{OBJ}_{\text{OLS}} \propto \sum_{}^{}{(Y_{\text{obs}} - Y_{\text{pred}})}^{2}\]</span></p>
<p>그림2 에서와 같이 직선 형태의 1차 함수로 자료를 설명하는 경우, 모델은 기울기 및 y 절편의 두 개 파라미터를 갖게 되고 이
두 개 파라미터의 조합으로 다양한 직선이 그려지며 그로부터 각각 잔차제곱합이 산출될 것이다. 이중 기울기가 2.114이고 y
절편은 0.934인 파라미터 조합일 때 잔차제곱합이 가장 작게 되고, 이 값을 모델의 파라미터로 추정하는 방식이 OLS
방식이다.</p>
</div>
<div id="wls-방식" class="section level3" number="9.2.2">
<h3><span class="header-section-number">9.2.2</span> WLS 방식</h3>
<p>WLS (weighted least square) 방식은 관찰값별로 정해진 가중요소(weighting factor)를 주어
선형회귀를 한다는 점이 OLS와 다른 점이다.</p>
<p><span class="math display">\[\text{OBJ}_{\text{WLS}} \propto \sum_{}^{}\left\{ W \times {(Y_{\text{obs}} - Y_{\text{pred}})}^{2} \right\}\]</span></p>
<p>OLS 방식에서는 관찰값이 모두 동일한 가치를 지니고 있으므로 특히 어떤 관찰값에서의 잔차를 최소화 해야 하는가에 대한 기준이
없다. 반면 WLS 방식에서는 보다 정확하게 회귀해야 하는 값에 더 큰 가중요소를 부여함으로써 선형회귀를 하게 된다. 이때
가중요소는 관찰값 분산의 역수로 설정하는 경우가 많지만, 다른 방식도 가능하다. 다시 말해 특정 시점의 값이 유사하게 관찰되어
관찰값 분산이 가장 작다면 그 시점에 가장 큰 가중요소를 부여함으로써 잔차제곱합을 최소화할 때 해당 관찰값의 잔차를 줄이는
것이 보다 영향력을 갖도록 하는 방식이다.</p>
<p>그런데 예측값이 아닌 관찰값 변이를 가중요소로 이용하면 관찰 자체에 따른 변이도 포함되어 가중요소 설정이 부정확할 수 있다. 모든
시점의 관찰값 변이가 유사하면서 작을 경우 파라미터 추정을 신뢰할 수 있지만, 관찰값 변이가 균등하지 않거나 전반적으로 크다면
일부 가중요소는 부적절하게 설정되며 이를 활용하여 산출한 파라미터의 신뢰도에 문제가 제기될 수 있다.</p>
</div>
<div id="els-방식" class="section level3" number="9.2.3">
<h3><span class="header-section-number">9.2.3</span> ELS 방식</h3>
<p>관찰값 변이를 이용한 WLS 방식에서의 가중요소 설정 한계를 보완하기 위해 예측값 변이를 고려하는 것이 ELS (extended
least square) 방식이다. 이 방식은 NONMEM에서 실제 활용하고 있는 것으로, 실행 시간은 오래 걸리지만 보다 정확한
값을 추정할 수 있는 것으로 알려져 있다.</p>
<p><span class="math display">\[\text{OBJ}_{\text{ELS}} \propto \sum_{}^{}\left\lbrack W \times {(Y_{\text{obs}} - Y_{\text{pred}})}^{2} + \ln\left\{ \text{Var}\left( Y_{\text{pred}} \right) \right\} \right\rbrack\]</span></p>
</div>
</div>
<div id="likelihood" class="section level2" number="9.3">
<h2><span class="header-section-number">9.3</span> Likelihood</h2>
<p>가능도(likelihood) 개념은 확률(probability)과 함께 이해하는 것이 좋다. 확률이라는 것은 파라미터 값이
주어졌을 때 아직 관찰되지 않은 결과를 예상할 때 사용한다. 즉, 앞면이 나올 가능성이 ½인 동전을 10번 던졌을
때 앞면이 몇 번 나올 것인지와 같은 물음에서 확률의 개념을 이해할 수 있다. 반면 가능도라는 것은 관찰된 결과를 알고 있는
상태에서 그런 결과가 예상되는 가능한 파라미터를 추정하는 것과 관련이 깊다. 앞서 예시를 응용하면, 동전을 10번 던져 앞면이
5번 나왔다는 사실에 근거할 때 동전의 앞면이 나올 확률은 ½일 가능성이 가장 높다고 말할 수 있다. 다시 말해 확률이 파라미터가
주어졌을 때 관찰값에 대한 함수라면, 가능도는 관찰값이 주어졌을 때 파라미터에 대한 함수로 볼 수 있다. 이런 이유로 가능도는
여러 추정 가능한 파라미터에 대한 분포 형태로 표현되며, 앞서 예시에서 실제 확률은 ½이 아닐 수도 있지만 ½일 가능성이
가장 높은, 즉 최대가능도(maximum likelihood) 값을 갖는 파라미터는 ½이라고 할 수 있다.</p>
<p>우리가 모델을 통해 확인하고자 하는 파라미터는 NONMEM에서 θ 형태로 표현되며, 약동학에서 청소율, 분포용적 등이 이에
해당하고 앞서 예시의 경우 앞면이 나올 확률이다. 아래 그림은 동전을 던져 앞면이 일곱번 나왔을 때 동전 앞면이
나올 확률, 즉 추정하고자 하는 파라미터에 대한 가능도를 나타낸 것이다. 예상한 바와 같이 앞면이 나올 확률이 0.7인
경우 가능도가 가장 크며, 이는 앞면이 나올 확률이 0.7인 동전일 때 관찰 결과를 가장 잘 설명함을 의미한다.</p>
<p><img src="assets/media-09/image5.emf" /></p>
<p>평균이 μ이고 표준편차가 σ인 정규분포를 따르는 확률변수 x를 가정할 때, 파라미터 θ의 가능도를 구하는 함수는 아래와 같다.</p>
<p><span class="math display">\[L\left( \theta \middle| \mathcal{x} \right) = P\left( \mathcal{x}_{1} \right|\widehat{\theta}) \times P\left( \mathcal{x}_{2} \right|\widehat{\theta}) \times \cdots \times P\left( \mathcal{x}_{n} \right|\widehat{\theta}) = \left( 2\pi \right)^{- \frac{1}{2}n} \times \prod_{\mathcal{i}\text{=1}}^{n}\left( (\sigma_{i}^{2})^{- \frac{1}{2}} \times e^{- {\ \frac{1}{{2\sigma}_{i}^{2}}\left( x_{i} - \widehat{\theta} \right)}^{2}} \right)\]</span></p>
<p>위 식의 양변을 로그변환한 식 및 그 식에 -2를 곱한 식은 각각 아래와 같다.</p>
<p><span class="math display">\[\ln{(L)} = - \frac{1}{2}n\ln\left( 2\pi \right) - \frac{1}{2}\sum_{\mathcal{i} = 1}^{n}\left( \ln{(\sigma_{i}^{2})} + \frac{\left( x_{i} - \widehat{\theta} \right)^{2}}{\sigma_{i}^{2}} \right)\]</span></p>
<p><span class="math display">\[- 2\ln{(L)} = n\ln\left( 2\pi \right) + \sum_{\mathcal{i} = 1}^{n}\left( \ln{(\sigma_{i}^{2})} + \frac{\left( x_{i} - \widehat{\theta} \right)^{2}}{\sigma_{i}^{2}} \right) \propto \text{OFV}\]</span></p>
<p>이처럼 가능도 식을 로그변환하여 -2를 곱하면 목적함수 계산식을 얻을 수 있고, 가능도를 최대로 한다는 건 목적함수 값을 최소로
한다는 것과 같은 의미로 해석됨을 알 수 있다.</p>
</div>
<div id="taylor-전개식" class="section level2" number="9.4">
<h2><span class="header-section-number">9.4</span> Taylor 전개식</h2>
<p><span class="math display">\[f(x) = \sum_{n = 0}^{\infty}\frac{f^{\left( n \right)}\left( \alpha \right)}{n!}{(x - \alpha)}^{n}\]</span></p>
<p>위 식은 미분가능한 함수를 다항식 형태로 변환한 것으로, 이런 변환을 통해 참값에 근사한 해를 구할 수 있다. 엄밀한 해를 구하기
위해서는 무한대 차수까지 모든 도함수의 합을 활용해야 하지만, NONMEM에서 FO 및 FOCE 방법으로 파라미터를 산출하는 경우
첫 번째 도함수만 활용하고 이후 도함수는 모두 무시하여 근사한 해를 구하고 Laplacian 방법에서는 두 번째 도함수까지
활용하여 해를 구한다.</p>
</div>
<div id="likelihood-ratio-test" class="section level2" number="9.5">
<h2><span class="header-section-number">9.5</span> Likelihood Ratio Test</h2>
<p>단순한 모델에 파라미터를 추가해 보다 복잡하게 만드는 등 하나의 모델이 다른 모델의 특수 형태인 서로 관련된 모델간 적합도를
비교하기 위해 가능도비를 검정한다. 각 모델에서 산출된 목적함수 값의 차이는 모델에서 사용된 파라미터 개수 차이를
자유도로 갖는 <em>Χ</em><sup>2</sup> 분포를 따른다는 특성을 이용한다. 즉 가능도를 로그변환한 것이 목적함수
형태로 표현되므로, 모델간 가능도비를 로그변환한다는 것은 목적함수 값의 차이를 의미한다. 이 목적함수 값의 차이와 해당
자유도에서의 <em>Χ</em><sup>2</sup> 분포 값을 비교함으로써 통계적으로 우수한 모델을 판정할 수 있다. 이때 비교하고자 하는
목적함수 값은 동일한 자료를 이용하여 동일한 잔차 형태를 가정한 모델로부터 산출된 것이어야 한다.</p>

</div>
</div>
            </section>

          </div>
        </div>
      </div>
<a href="초기추정값.html" class="navigation navigation-prev " aria-label="Previous page"><i class="fa fa-angle-left"></i></a>
<a href="nonmem-실행결과-해석-및-xpose4-사용법.html" class="navigation navigation-next " aria-label="Next page"><i class="fa fa-angle-right"></i></a>
    </div>
  </div>
<script src="libs/gitbook/js/app.min.js"></script>
<script src="libs/gitbook/js/lunr.js"></script>
<script src="libs/gitbook/js/clipboard.min.js"></script>
<script src="libs/gitbook/js/plugin-search.js"></script>
<script src="libs/gitbook/js/plugin-sharing.js"></script>
<script src="libs/gitbook/js/plugin-fontsettings.js"></script>
<script src="libs/gitbook/js/plugin-bookdown.js"></script>
<script src="libs/gitbook/js/jquery.highlight.js"></script>
<script src="libs/gitbook/js/plugin-clipboard.js"></script>
<script>
gitbook.require(["gitbook"], function(gitbook) {
gitbook.start({
"sharing": {
"github": true,
"facebook": false,
"twitter": true,
"linkedin": false,
"weibo": false,
"instapaper": false,
"vk": false,
"all": ["facebook", "twitter", "linkedin", "weibo", "instapaper"]
},
"fontsettings": {
"theme": "white",
"family": "sans",
"size": 2
},
"edit": {
"link": "https://github.com/pipetcpt/book-basic-1/edit/master/inst/examples/09.Rmd",
"text": "Edit"
},
"history": {
"link": null,
"text": null
},
"view": {
"link": null,
"text": null
},
"download": ["book-basic-1.pdf", "book-basic-1.epub", "book-basic-1.mobi"],
"toc": {
"collapse": "section"
}
});
});
</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    var src = "true";
    if (src === "" || src === "true") src = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML";
    if (location.protocol !== "file:")
      if (/^https?:/.test(src))
        src = src.replace(/^https?:/, '');
    script.src = src;
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>
</body>

</html>
